#============================================================
# R的部分基础操作
#============================================================

#------------------------------------------------------------
# 创建的每个对象都将存储在计算机内存中，知道删除它。可能通过
# 输入ls()或objects()命令来列举出当前内存中的对象。如果不需要
# 一个对象了可以通过删除它来释放一些内存空间。
#------------------------------------------------------------

a<-100
b=100   # 赋值的两种方式
        # 对象名称可以包括任何大小写字母、数字0~9（不能用作
        # 名称开头）以及和字母作用相似的符号“.”
        # 注意！R区分大小写！

ls()
objects()   # 两种方式查看当前内存中的对象
rm(a)       # 删除对象
ls()

#------------------------------------------------------------
# 一个向量的所有元素都必须属于相同模式，如果不是，R将强制
# 执行类型转换。
#------------------------------------------------------------
v<-c(4,7,23.5,76.2,80,"rrt")   # 建立向量
v   # 向量的所有元素已经转换为字符模式

#------------------------------------------------------------
# 向量可以包括一个特殊值，即NA。表示缺失值。
#------------------------------------------------------------
u<-c(4,6,NA,2)
u

x<-vector()   # R允许建立空向量
length(x)
x[3]<-45
x             # 使用不存在的索引添加向量元素可以改变向量长度
length(x)

#------------------------------------------------------------
# 因子
# 因子提供了一个简单而紧凑的形式来处理分类（名义）数据。因子
# 用水平来表示所有可能的取值。如果数据集有取值个数固定的名义
# 变量，因子就特别有用。对用户来说，这种使用和显示因子数据的
# 方式显然是易于理解的，而R软件内部以数值编码方式来存储因子
# 值，这将大大提高内存的利用效率。
#------------------------------------------------------------
g<-c("f","m","m","m","f","m","f","m","f","f")
g     # 假设有一个10个人的性别变量
g<-factor(g)
g     # 可以把这个向量转换为一个因子
summary(g)

other.g<-factor(c("f","f","f","f","f"),levels=c("f","m"))
      # 假设另外有5个人，需要把他们的性别信息存储在另一个因子
      # 对象中。假设他们都是女性。如果仍然需要与对象g有两个
      # 相同的因子水平，则使用上述命令
other.g

table(g)
table(other.g)   # 利用因子类型数据，可以做的事情之一是计算
                 # 每个可能值的发生次数

#------------------------------------------------------------
# table()函数也可以获取多个因子的交叉表。假设向量a存储10个人
# 所属的年龄，那么可以得到这两个向量的交叉表：
#------------------------------------------------------------
a<-factor(c("adult","adult","juvenile","juvenile","adult",
            "adult","adult","juvenile","adult","juvenile"))
table(a,g)

t<-table(a,g)
margin.table(t,1)
margin.table(t,2)
   # 有时我们希望计算列联表的边际和相对频率。参数“1”、“2”
   # 代表列联表的第一个和第二个维度，即行和列。

prop.table(t,1)
prop.table(t,2)
prop.table(t)
   # 每个维度边际和总计的相对频率

#------------------------------------------------------------
# 生成序列
#------------------------------------------------------------
x<-1:1000      # 生成包含1~1000所有整数的向量

10:15-1        # :优先级比减法高

5:0            # 同样可以生成递减序列

seq(-4,1,0.5)  # 从-4到1，间隔为0.5
seq(from=1,to=5,length=4)
seq(length=10,from=-2,by=0.2)
               # seq()函数的各种用法

rep(5,10)
rep("hi",3)
rep(1:2,3)
rep(1:2,each=3) # rep()函数的各种用法

gl(2,5)
gl(2,5,labels=c("female","male"))
                # 生成带有因子的序列

#------------------------------------------------------------
# 数据子集
# 可以在方括号内放入元素的位置获得向量中的元素，也允许在括号
# 中使用向量，负值索引向量表示哪些元素可以排除。
#------------------------------------------------------------
x<-c(0,-3,4,-1,45,90,-5)
x>0
x[x>0]
x[x<=2|x>5]
x[c(4,6)]
x[-c(4,6)]

pH<-c(4.5,7,7.3,8.2,6.3)
names(pH)<-c("area1","area2","mud","dam","middle")
pH   # names()函数可以给向量中的元素命名，可以通过名字调用
pH["mud"]

a<-1:5
a[]<-0
a     # 当索引为空表示所有元素都被选定
a<-0
a     # 注意和a<-0的区别

#------------------------------------------------------------
# 矩阵和数组
# 数据元素可以保存在具有多个维度的对象中。在多种情况下这尤其
# 有用。数组存储的是多维数据元素。矩阵是数组的特殊情况，它具
# 有两个维度。在R中，数组和矩阵都是带有维度这个特定属性的向量。
#------------------------------------------------------------
m<-c(45,23,66,77,33,44,56,12,78,23)
m

dim(m)<-c(2,5)
m
m<-matrix(c(1,2,3,4),2,2)
m
m<-matrix(c(1,2,3,4),2,2,byrow=TRUE)
m        # 可以按列排列也可以按行排列
m[1,2]   # 可以通过类似向量中的索引方法访问元素
m[1,]
m[,2]

m[,1,drop=F] # 若希望得到的子集仍是矩阵可用此命令

m1<-matrix(c(45,23,66,77,33,44,56,12,78,23),2,5)
m1
cbind(c(4,76),m1[,4])  # 按列把两个或以上的向量或矩阵合并

m2<-matrix(rep(10,20),4,5)
m2
m3<-rbind(m1[1,],m2[3,])
m3
colnames(m3)<-c("1qrt","2qrt","3qrt","4qrt","5qrt")
rownames(m3)<-c("store1","store2")
      # 可以用函数给矩阵的行和列命名
m3[,"2qrt"]

a<-array(1:24,dim=c(4,3,2))
a     # 创建数组
dimnames(a)<-list(first=1:4,second=1:3,third=1:2)
      # 为各个维度和行列命名

#------------------------------------------------------------
# 列表
# R列表是以其他对象为成分的有序集合。列表的成分和向量元素不同，
# 不一定是同一种数据类型、模式或者相同长度。列表的成分总是编号
# 的并且有一个名称属性。
#------------------------------------------------------------
my.list<-list(stud.id=34453,
              stud.name="John",
              stud.marks=c(14.3,12,15,19))
my.list
my.list[1]
my.list[[1]]   # 注意单括号和双括号的区别

mode(my.list[1])
mode(my.list[[1]])
my.list$stud.id  # 列表用另一种方式提取列表成分的值
names(my.list)
names(my.list)<-c("id","name","marks")
my.list          # 列表成分的名称可以进行操作
my.list$parents.names<-c("Ana","Mike")
my.list          # 可以通过添加附加元素的方式扩展列表
lst<-c(my.list,list(age=19,sex="male"))
                 # 可以通过c()合并列表
unlist(lst)      # 把列表的所有元素转换为向量元素，该操作
                 # 将列表中不同类型的数据转为统一的类型

#------------------------------------------------------------
# 数据框
# 用于存储数据表的一种数据结构。每列可以是不同数据类型的数据。
#------------------------------------------------------------
my.dataset<-data.frame(site=c('A','B','A','A','B'),
                       season=c('Winter','Summer','Summer',
                                'Spring','Fall'),
                       pH=c(7.4,6.3,8.6,7.2,8.9))
my.dataset
my.dataset[3,2]  # 可以像矩阵那样访问数据框的元素
my.dataset$pH
my.dataset[my.dataset$pH>7,]

attach(my.dataset)  # 可直接访问数据框的列，无需添加数据框名
detach(my.dataset)  # 反向操作
subset(my.dataset,pH>8)
subset(my.dataset,season=="Summer",season:pH)
